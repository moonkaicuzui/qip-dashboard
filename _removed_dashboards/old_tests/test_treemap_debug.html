<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Treemap Debug Test</title>
    <style>
        #testTreemap {
            width: 800px;
            height: 600px;
            border: 1px solid #ccc;
            position: relative;
            margin: 20px;
        }
        .treemap-cell {
            position: absolute;
            border: 1px solid #fff;
            overflow: hidden;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2px;
            box-sizing: border-box;
        }
        .role-sector {
            position: absolute;
            border: 2px solid #333;
            background: rgba(200, 200, 200, 0.1);
            overflow: hidden;
        }
        .role-label {
            position: absolute;
            top: 2px;
            left: 2px;
            font-weight: bold;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 5px;
            border-radius: 3px;
            z-index: 10;
        }
        .position-box {
            position: absolute;
            border: 1px solid #666;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 10px;
            cursor: pointer;
        }
        .position-box:hover {
            opacity: 0.8;
            border: 2px solid #000;
        }
    </style>
</head>
<body>
    <h1>Treemap Debug Test</h1>
    <div id="testTreemap"></div>
    <div id="errorLog"></div>

    <script>
        // Squarified Treemap Algorithm
        function squarify(data, container) {
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            const area = width * height;
            
            // Calculate scale factor
            const totalValue = data.reduce((sum, d) => sum + d.value, 0);
            const scale = area / totalValue;
            
            // Scale values
            const scaledData = data.map(d => ({
                ...d,
                scaledValue: d.value * scale
            }));
            
            // Sort by value (largest first)
            scaledData.sort((a, b) => b.scaledValue - a.scaledValue);
            
            const rectangles = [];
            let x = 0, y = 0, dx = width, dy = height;
            
            function layoutRow(row, width, height, x, y) {
                const rowArea = row.reduce((sum, d) => sum + d.scaledValue, 0);
                let currentX = x;
                
                row.forEach(item => {
                    const itemWidth = rowArea / height;
                    const itemHeight = item.scaledValue / itemWidth;
                    
                    rectangles.push({
                        ...item,
                        x: currentX,
                        y: y,
                        width: itemWidth,
                        height: itemHeight
                    });
                    
                    currentX += itemWidth;
                });
            }
            
            function layoutColumn(col, width, height, x, y) {
                const colArea = col.reduce((sum, d) => sum + d.scaledValue, 0);
                let currentY = y;
                
                col.forEach(item => {
                    const itemHeight = colArea / width;
                    const itemWidth = item.scaledValue / itemHeight;
                    
                    rectangles.push({
                        ...item,
                        x: x,
                        y: currentY,
                        width: itemWidth,
                        height: itemHeight
                    });
                    
                    currentY += itemHeight;
                });
            }
            
            function worst(row, w) {
                if (row.length === 0) return Infinity;
                const rMax = Math.max(...row.map(d => d.scaledValue));
                const rMin = Math.min(...row.map(d => d.scaledValue));
                const rSum = row.reduce((sum, d) => sum + d.scaledValue, 0);
                const ratio1 = (w * w * rMax) / (rSum * rSum);
                const ratio2 = (rSum * rSum) / (w * w * rMin);
                return Math.max(ratio1, ratio2);
            }
            
            function squarifyRecursive(data, x, y, dx, dy) {
                if (data.length === 0) return;
                if (data.length === 1) {
                    rectangles.push({
                        ...data[0],
                        x: x,
                        y: y,
                        width: dx,
                        height: dy
                    });
                    return;
                }
                
                const shorter = Math.min(dx, dy);
                const row = [];
                let remaining = [...data];
                
                while (remaining.length > 0) {
                    const next = remaining[0];
                    const rowWithNext = [...row, next];
                    
                    if (row.length === 0 || worst(rowWithNext, shorter) < worst(row, shorter)) {
                        row.push(next);
                        remaining.shift();
                    } else {
                        break;
                    }
                }
                
                if (dx >= dy) {
                    layoutColumn(row, dx, dy, x, y);
                    const rowWidth = row.reduce((sum, d) => sum + d.scaledValue, 0) / dy;
                    if (remaining.length > 0) {
                        squarifyRecursive(remaining, x + rowWidth, y, dx - rowWidth, dy);
                    }
                } else {
                    layoutRow(row, dx, dy, x, y);
                    const rowHeight = row.reduce((sum, d) => sum + d.scaledValue, 0) / dx;
                    if (remaining.length > 0) {
                        squarifyRecursive(remaining, x, y + rowHeight, dx, dy - rowHeight);
                    }
                }
            }
            
            squarifyRecursive(scaledData, x, y, dx, dy);
            return rectangles;
        }

        // Test data
        const testRoleGroups = {
            'INSPECTOR': [
                { name: 'ASSEMBLY INSPECTOR', value: 100 },
                { name: 'QA INSPECTOR', value: 50 },
                { name: 'BOTTOM INSPECTOR', value: 30 }
            ],
            'MID-MANAGEMENT': [
                { name: 'TEAM LEADER', value: 40 },
                { name: 'LINE MANAGER', value: 35 },
                { name: 'SUPERVISOR', value: 25 }
            ],
            'TOP-MANAGEMENT': [
                { name: 'DIRECTOR', value: 5 },
                { name: 'MANAGER', value: 8 }
            ]
        };

        function createRoleTreemap(teamName, roleGroups) {
            const container = document.getElementById('testTreemap');
            container.innerHTML = '';
            
            console.log('Creating treemap for team:', teamName);
            console.log('Role groups:', roleGroups);
            
            try {
                // Calculate total for each role (sector)
                const sectors = Object.entries(roleGroups).map(([role, positions]) => ({
                    name: role,
                    value: positions.reduce((sum, p) => sum + p.value, 0),
                    positions: positions
                }));
                
                console.log('Sectors:', sectors);
                
                // Create treemap layout for sectors
                const sectorRects = squarify(sectors, container);
                console.log('Sector rectangles:', sectorRects);
                
                // Create sector containers
                sectorRects.forEach(sector => {
                    const sectorDiv = document.createElement('div');
                    sectorDiv.className = 'role-sector';
                    sectorDiv.style.left = `${sector.x}px`;
                    sectorDiv.style.top = `${sector.y}px`;
                    sectorDiv.style.width = `${sector.width}px`;
                    sectorDiv.style.height = `${sector.height}px`;
                    
                    // Add sector label
                    const label = document.createElement('div');
                    label.className = 'role-label';
                    label.textContent = `${sector.name} (${sector.value}명)`;
                    sectorDiv.appendChild(label);
                    
                    // Create position boxes within sector
                    if (sector.positions && sector.positions.length > 0) {
                        // Create a container for positions (offset for label)
                        const posContainer = {
                            offsetWidth: sector.width - 4,
                            offsetHeight: sector.height - 25
                        };
                        
                        const positionRects = squarify(sector.positions, posContainer);
                        
                        positionRects.forEach(pos => {
                            const posDiv = document.createElement('div');
                            posDiv.className = 'position-box';
                            posDiv.style.left = `${pos.x + 2}px`;
                            posDiv.style.top = `${pos.y + 23}px`;
                            posDiv.style.width = `${pos.width}px`;
                            posDiv.style.height = `${pos.height}px`;
                            posDiv.style.backgroundColor = `hsl(${Math.random() * 60 + 180}, 70%, 70%)`;
                            
                            // Add position text if space allows
                            if (pos.height > 20 && pos.width > 40) {
                                posDiv.innerHTML = `
                                    <div style="font-weight: bold;">${pos.name}</div>
                                    <div>${pos.value}명</div>
                                `;
                            } else if (pos.height > 15) {
                                posDiv.textContent = `${pos.value}`;
                            }
                            
                            posDiv.title = `${pos.name}: ${pos.value}명`;
                            sectorDiv.appendChild(posDiv);
                        });
                    }
                    
                    container.appendChild(sectorDiv);
                });
                
                document.getElementById('errorLog').innerHTML = '<p style="color: green;">Treemap created successfully!</p>';
                
            } catch (error) {
                console.error('Error creating treemap:', error);
                document.getElementById('errorLog').innerHTML = `<p style="color: red;">Error: ${error.message}</p>`;
            }
        }

        // Test the function
        window.onload = function() {
            createRoleTreemap('ASSEMBLY', testRoleGroups);
        };
    </script>
</body>
</html>